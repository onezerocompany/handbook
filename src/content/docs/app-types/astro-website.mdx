---
title: Astro Website Standards
---

## Overview

Astro is our framework for building content-focused websites, marketing pages, and documentation sites. Astro's islands architecture delivers minimal JavaScript to the browser while supporting components from React, Vue, Svelte, and other frameworks. Our Astro sites emphasize performance, SEO, and excellent developer experience.

## Islands Architecture

We leverage Astro's islands architecture to ship zero JavaScript by default, with interactive islands only where needed. Static components render as pure HTML, while interactive components hydrate on the client only when necessary. This approach delivers excellent performance and fast page loads.

Interactive islands are added with directives like `client:load`, `client:visible`, or `client:idle` based on when they should hydrate. We prefer delayed hydration (`client:visible`, `client:idle`) to improve initial page load performance.

## Component Framework

We use React for interactive components within Astro sites. React components integrate seamlessly with Astro and provide familiar patterns for building interactive UI. Components are kept small and focused, with clear boundaries between static and interactive content.

Astro components (`.astro` files) are used for static layout and content that doesn't require interactivity. These compile to pure HTML with zero client-side JavaScript overhead.

## Styling

We use Tailwind CSS for styling Astro sites. Tailwind provides utility-first styling with excellent design consistency and developer experience. Astro has first-class Tailwind support with automatic optimization.

For component libraries, we use shadcn/ui or custom components built with Tailwind. This provides accessible, well-designed components that integrate smoothly with Tailwind workflows.

## Content Management

We use Astro's content collections for managing markdown and MDX content. Content collections provide type-safe frontmatter, automatic validation with Zod schemas, and excellent developer experience. Collections are defined in the `content` directory with clear schemas.

MDX support enables rich, interactive content with embedded components. We use MDX for documentation and content-heavy pages where interactivity enhances the experience.

## Routing

Astro uses file-based routing where the file structure determines routes. We organize pages clearly in the `src/pages` directory. Dynamic routes use bracket notation (`[slug].astro`) and support catch-all routes.

API routes provide server-side functionality for forms, webhooks, and dynamic data. API routes are defined in `src/pages/api` and return JSON or other response types.

## Image Optimization

We use Astro's built-in image optimization through the Image component. Images are automatically optimized, resized, and served in modern formats like WebP and AVIF. This improves performance without manual optimization workflows.

Images are stored in the `public` directory or imported directly in components. Imported images get additional optimization and type safety.

## SEO

We implement comprehensive SEO through metadata, structured data, sitemaps, and RSS feeds. Astro makes SEO straightforward with built-in support for head tags, canonical URLs, and meta descriptions.

We use Open Graph and Twitter Card metadata for social sharing. Structured data (JSON-LD) is added for rich search results. Sitemaps are automatically generated for search engine discovery.

## Performance

Astro sites are highly performant by default through static site generation and minimal JavaScript. We optimize further through lazy loading, image optimization, and efficient CSS delivery. We track Core Web Vitals to ensure excellent user experience.

Bundle size is monitored in CI to prevent performance regressions. We use bundle analysis to identify and eliminate unnecessary dependencies.

## Internationalization

We use react-i18next or Astro's i18n features for internationalization. Content collections support multiple languages through separate directories or frontmatter fields. Routes are organized by locale when supporting multiple languages.

## Build and Deployment

Astro sites are built as static sites or server-rendered depending on requirements. Static sites deploy to Cloudflare Pages, Railway, or other static hosting. Server-rendered sites (SSR mode) deploy to platforms supporting Node.js or edge runtimes.

Preview deployments are created for every pull request, enabling visual review before merging.

## Testing

We use Playwright for end-to-end testing of Astro sites. Playwright tests verify complete user flows, navigation, forms, and interactive islands. We use visual regression testing to catch unintended UI changes.

Component testing uses Jest or Vitest for React components embedded in Astro sites. We test interactive islands independently before integrating them.

## Performance Monitoring

We track Core Web Vitals including Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS). PostHog or similar tools provide real user monitoring and performance insights.

## Accessibility

We ensure WCAG 2.1 AA compliance for all pages. Astro's minimal JavaScript approach helps accessibility by default. We add ARIA labels, semantic HTML, and keyboard navigation for interactive components.

## Rules

1. Use Astro for content-focused websites, marketing pages, and documentation
2. Leverage islands architecture for minimal JavaScript delivery
3. Ship zero JavaScript by default, interactive islands only where needed
4. Use client:visible or client:idle for delayed hydration
5. Prefer delayed hydration over immediate (client:load)
6. Use React for interactive components within Astro
7. Use .astro files for static layout and content
8. Keep components small and focused
9. Clear boundaries between static and interactive content
10. Use Tailwind CSS for styling
11. Use shadcn/ui or custom components for component library
12. Use Astro content collections for markdown and MDX content
13. Define content schemas with Zod for type safety
14. Use MDX for rich, interactive content
15. Use file-based routing in src/pages directory
16. Use bracket notation for dynamic routes ([slug].astro)
17. Define API routes in src/pages/api
18. API routes return JSON or other response types
19. Use Astro's Image component for image optimization
20. Automatically optimize images in WebP and AVIF formats
21. Store images in public directory or import in components
22. Implement comprehensive SEO with metadata and structured data
23. Generate sitemaps automatically
24. Use Open Graph and Twitter Card metadata
25. Add structured data (JSON-LD) for rich search results
26. Track Core Web Vitals (LCP, FID, CLS)
27. Monitor bundle size in CI
28. Use bundle analysis to eliminate unnecessary dependencies
29. Lazy load images and heavy content
30. Use react-i18next or Astro i18n for internationalization
31. Support multiple languages through content collections
32. Organize routes by locale for multi-language sites
33. Build as static sites or server-rendered based on requirements
34. Deploy static sites to Cloudflare Pages or Railway
35. Deploy SSR sites to Node.js or edge runtime platforms
36. Create preview deployments for pull requests
37. Use Playwright for end-to-end testing
38. Use visual regression testing for UI changes
39. Use Jest or Vitest for component testing
40. Test interactive islands independently
41. Track Core Web Vitals with real user monitoring
42. Use PostHog or similar for performance insights
43. Ensure WCAG 2.1 AA compliance
44. Use semantic HTML and ARIA labels
45. Support keyboard navigation for interactive components
46. Tests required for critical user flows
47. Minimum 80% coverage for interactive components
